<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Rust-learning -- 所有权（一） | Somewan world</title><meta name="author" content="Some"><meta name="copyright" content="Some"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="所有权（一）What is ownership？Rust 的核心功能（之一）是 所有权（ownership）。 所有运行的程序都必须管理其使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存；在另一些语言中，开发者必须亲自分配和释放内存。Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust-learning -- 所有权（一）">
<meta property="og:url" content="http://example.com/2024/05/04/Rust-L1/index.html">
<meta property="og:site_name" content="Somewan world">
<meta property="og:description" content="所有权（一）What is ownership？Rust 的核心功能（之一）是 所有权（ownership）。 所有运行的程序都必须管理其使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存；在另一些语言中，开发者必须亲自分配和释放内存。Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2.imgtp.com/2024/04/30/cXrphmbj.jpg">
<meta property="article:published_time" content="2024-05-04T15:48:44.000Z">
<meta property="article:modified_time" content="2024-05-05T09:14:37.350Z">
<meta property="article:author" content="Some">
<meta property="article:tag" content="Rust-learning🦀">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2.imgtp.com/2024/04/30/cXrphmbj.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2024/05/04/Rust-L1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Rust-learning -- 所有权（一）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-05 17:14:37'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all"><meta name="generator" content="Hexo 7.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img2.imgtp.com/2024/04/30/NSnFYQHs.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img2.imgtp.com/2024/04/30/cXrphmbj.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Somewan world"><span class="site-name">Somewan world</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Rust-learning -- 所有权（一）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-04T15:48:44.000Z" title="发表于 2024-05-04 23:48:44">2024-05-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-05T09:14:37.350Z" title="更新于 2024-05-05 17:14:37">2024-05-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Rust%F0%9F%A6%80/">Rust🦀</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Rust-learning -- 所有权（一）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="所有权（一）What-is-ownership？"><a href="#所有权（一）What-is-ownership？" class="headerlink" title="所有权（一）What is ownership？"></a>所有权（一）What is ownership？</h1><p>Rust 的核心功能（之一）是 所有权（ownership）。</p>
<p>所有运行的程序都必须管理其使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存；在另一些语言中，开发者必须亲自分配和释放内存。Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序</p>
<h2 id="Stack-Heap"><a href="#Stack-Heap" class="headerlink" title="Stack &amp; Heap"></a>Stack &amp; Heap</h2><p>栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。栈以放入值的顺序存储值并以相反顺序取出值。这也被称作<strong>后进先出（last in, first out）</strong>。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，也从顶部拿走。不能从中间也不能从底部增加或拿走盘子！增加数据叫做<strong>进栈（pushing onto the stack）</strong>，而移出数据叫做<strong>出栈（popping off the stack）</strong></p>
<p>栈中的所有数据都必须占用已知且固定的大小。在编译时大小未知或大小可能变化的数据，要改为存储在堆上。堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。<strong>内存分配器（memory allocator）</strong>在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的<strong>指针（pointer）</strong>。这个过程称作<strong>在堆上分配内存（allocating on the heap）</strong>，简称为 <strong>“分配”（allocating）</strong>。将数据推入栈中并不被认为是分配。因为指针的大小是已知并且固定的，你可以将指针存储在栈上，不过当需要实际数据时，必须访问指针。</p>
<p>入栈比在堆上分配内存要快，因为（入栈时）分配器无需为存储新数据去搜索内存空间；其位置总是在栈顶。相比之下，在堆上分配内存则需要更多的工作，这是因为分配器必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。</p>
<p>访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存）。出于同样原因，处理器在处理的数据彼此较近的时候（比如在栈上）比较远的时候（比如可能在堆上）能更好的工作。在堆上分配大量的空间也可能消耗时间。</p>
<p>跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了所有权的存在就是为了管理堆数据，能够帮助解释为什么所有权要以这种方式工作。</p>
<h2 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h2><ul>
<li>Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。</li>
<li>值在任一时刻有且只有一个所有者</li>
<li>当所有者（变量）离开作用域，这个值将被丢弃。</li>
</ul>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>作用域是一个项（item）在程序中有效的范围。假设有这样一个变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">let s = &quot;hello&quot;;<br></code></pre></td></tr></table></figure>
<p>变量 s 绑定到了一个字符串字面量，这个字符串值是硬编码进程序代码中的。这个变量从声明的点开始直到当前 作用域 结束时都是有效的.注释标明了变量 s 在何处是有效的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123;                      // s 在这里无效, 它尚未声明<br>    let s = &quot;hello&quot;;   // 从此处起，s 开始有效<br>    // 使用 s<br>&#125;                      // 此作用域已结束，s 不再有效<br></code></pre></td></tr></table></figure>
<p>这里有两个重要的时间点：</p>
<ul>
<li>当 s 进入<strong>作用域</strong>时，它就是有效的。</li>
<li>这一直持续到它<strong>离开作用域</strong>为止。</li>
</ul>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>我们已经见过字符串字面量，即被硬编码进程序里的字符串值。字符串字面量是很方便的，不过它们并不适合使用文本的每一种场景。原因之一就是它们是不可变的。另一个原因是并非所有字符串的值都能在编写代码时就知道：例如，要是想获取用户输入并存储该怎么办呢？为此，Rust 有第二个字符串类型，String。这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。可以使用 from 函数基于字符串字面量来创建 String，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">let s = String::from(&quot;hello&quot;);<br></code></pre></td></tr></table></figure>
<p>两个冒号（::）是运算符，允许将特定的 from 函数置于 String 类型的命名空间（namespace）下，而不需要使用类似 string_from 这样的名字。</p>
<p>可以修改此类字符串 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">let mut s = String::from(&quot;hello&quot;);<br>s.push_str(&quot;, world!&quot;); // push_str() 在字符串后追加字面值<br>println!(&quot;&#123;&#125;&quot;, s); // 将打印 `hello, world!`<br></code></pre></td></tr></table></figure>
<p>那么这里有什么区别呢？为什么 String 可变而字面量却不行呢？区别在于两个类型对内存的处理上。</p>
<h2 id="内存和分配"><a href="#内存和分配" class="headerlink" title="内存和分配"></a>内存和分配</h2><p>就字符串字面量来说，我们在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中。这使得字符串字面量快速且高效。不过这些特性都只得益于字符串字面量的不可变性。我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件<br>中，并且它的大小还可能随着程序运行而改变。</p>
<p>对于 String 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：</p>
<ul>
<li>必须在运行时向内存分配器请求内存。</li>
<li>需要一个当我们处理完 String 时将内存返回给分配器的方法。<br>第一部分由我们完成：当调用 String::from 时，它的实现 (implementation) 请求其所需的内存。</li>
</ul>
<p>第二部分实现起来就各有区别了。在有<strong>垃圾回收（garbage collector，GC）</strong>的语言中，GC记录并清除不再使用的内存，而我们并不需要关心它。没有GC的话，识别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样。从历史的角度上说正确处理内存回收曾经是一个困难的编程问题。如果忘记回收了会浪费内存。如果过早回收了，将会出现无效变量。如果重复回收，这也是个bug。我们需要精确的为一个allocate 配对一个free。</p>
<p>Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。下面是作用域例子的一个使用 String 而不是字符串字面量的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123;<br>    let s = String::from(&quot;hello&quot;); // 从此处起，s 开始有效<br><br>    // 使用 s<br>&#125;                                  // 此作用域已结束，<br>                                   // s 不再有效<br></code></pre></td></tr></table></figure>
<p>这是一个将 String 需要的内存返回给分配器的很自然的位置：当 s 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 drop，在这里 String 的作者可以放置释放内存的代码。Rust 在结尾的 <strong>}</strong> 处自动调用 drop。</p>
<p>几个场景：</p>
<h3 id="变量与数据交互的方式（一）：移动"><a href="#变量与数据交互的方式（一）：移动" class="headerlink" title="变量与数据交互的方式（一）：移动"></a>变量与数据交互的方式（一）：移动</h3><p>在 Rust 中，多个变量能够以不同的方式与同一数据交互。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">let x = 5;<br>let y = x;<br></code></pre></td></tr></table></figure>
<p>“将 5 绑定到 x；接着生成一个值 x 的拷贝并绑定到 y”。现在有了两个变量，x 和 y，都等于 5。这也正是事实上发生了的，因为整数是有已知固定大小的简单值，所以这两个 5 被放入了栈中。</p>
<p>String 版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">let s1 = String::from(&quot;hello&quot;);<br>let s2 = s1;<br></code></pre></td></tr></table></figure>
<p>这看起来与上面的代码非常类似，所以我们可能会假设他们的运行方式也是类似的：也就是说，第二行可能会生成一个 s1 的拷贝并绑定到 s2 上。不过，事实上并不完全是这样。</p>
<p>看看下图以了解 String 的底层会发生什么。String 由三部分组成，如图左侧所示：一个指向存放字符串内容内存的指针，一个长度，和一个容量。这一组数据存储在栈上。右侧则是堆上存放内容的内存部分。<br><img src="https://img2.imgtp.com/2024/05/05/b2hCjM8r.png"></p>
<p>长度表示 String 的内容当前使用了多少字节的内存。容量是 String 从分配器总共获取了多少字节的内存。长度与容量的区别是很重要的，不过在当前上下文中并不重要，所以现在可以忽略容量。</p>
<p>当我们将 s1 赋值给 s2，String 的数据被复制了，这意味着我们从栈上拷贝了它的指针、长度和容量。我们并没有复制指针指向的堆上数据。换句话说，内存中数据的表现下图所示。<br><img src="https://img2.imgtp.com/2024/05/05/ngbbnENg.png"><br>这个表现形式看起来 并不像下图中的那样，如果 Rust 也拷贝了堆上的数据，那么内存看起来就是这样的。如果 Rust 这么做了，那么操作 s2 &#x3D; s1 在堆上数据比较大的时候会对运行时性能造成非常大的影响<br><img src="https://img2.imgtp.com/2024/05/05/gkxdkePa.png"><br>之前我们提到过当变量离开作用域后，Rust 自动调用 drop 函数并清理变量的堆内存。不过图 4-2 展示了两个数据指针指向了同一位置。这就有了一个问题：当 s2 和 s1 离开作用域，他们都会尝试释放相同的内存。这是一个叫做 二次释放（double free）的错误，也是之前提到过的内存安全性 bug 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。</p>
<p>为了确保内存安全，这种场景下 Rust 的处理有另一个细节值得注意。在 let s2 &#x3D; s1 之后，Rust 认为 s1 不再有效，因此 Rust 不需要在 s1 离开作用域后清理任何东西。看看在 s2 被创建之后尝试使用 s1 会发生什么；这段代码不能运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">    let s1 = String::from(&quot;hello&quot;);<br>    let s2 = s1;<br><br>    println!(&quot;&#123;&#125;, world!&quot;, s1); //不能运行，无效引用<br><br>//报错<br>$ cargo run<br>   Compiling ownership v0.1.0 (file:///projects/ownership)<br>error[E0382]: borrow of moved value: `s1`<br> --&gt; src/main.rs:5:28<br>  |<br>2 |     let s1 = String::from(&quot;hello&quot;);<br>  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait<br>3 |     let s2 = s1;<br>  |              -- value moved here<br>4 | <br>5 |     println!(&quot;&#123;&#125;, world!&quot;, s1);<br>  |                            ^^ value borrowed here after move<br><br>For more information about this error, try `rustc --explain E0382`.<br>error: could not compile `ownership` due to previous error<br></code></pre></td></tr></table></figure>
<p>在其他语言中你可能听说过术语 浅拷贝（shallow copy）和 深拷贝（deep copy），那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。不过因为 Rust 同时使第一个变量无效了，这个操作被称为 移动（move），而不是浅拷贝。上面的例子可以解读为 s1 被 移动 到了 s2 中</p>
<hr>
<p>浅拷贝（Shallow Copy）是指创建一个新对象，该对象具有原始对象的一些属性或元素的副本。但是，如果属性或元素本身是引用其他对象的指针，那么浅拷贝只会复制这些指针，而不会创建它们指向的对象的副本。因此，在浅拷贝中，原始对象和副本对象将共享相同的引用对象。如果对共享的对象进行修改，这些修改将在原始对象和副本对象中都可见。</p>
<p>深拷贝（Deep Copy）是指创建一个新对象，该对象具有原始对象的所有属性或元素的副本，包括嵌套的对象。深拷贝会递归地复制所有引用对象，因此，在深拷贝中，原始对象和副本对象将完全独立，互不影响。</p>
<hr>
<p><img src="https://img2.imgtp.com/2024/05/05/rGWUgAsB.png"></p>
<p>只有 s2 是有效的，当其离开作用域，它就释放自己的内存！</p>
<p>另外，这里还隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 自动 的复制可以被认为对运行时性能影响较小。</p>
<h3 id="变量与数据交互的方式（二）：克隆"><a href="#变量与数据交互的方式（二）：克隆" class="headerlink" title="变量与数据交互的方式（二）：克隆"></a>变量与数据交互的方式（二）：克隆</h3><p>如果我们 确实 需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的通用函数。</p>
<p>一个实际使用 clone 方法的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">let s1 = String::from(&quot;hello&quot;);<br>let s2 = s1.clone();<br><br>println!(&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;, s1, s2);<br></code></pre></td></tr></table></figure>
<p>这段代码能正常运行，并且明确产生下图中的行为，这里堆上的数据确实被复制了<br><img src="https://img2.imgtp.com/2024/05/05/gkxdkePa.png"></p>
<p>当出现 clone 调用时，你知道一些特定的代码被执行而且这些代码可能相当消耗资源。</p>
<h3 id="只在栈上的数据：拷贝"><a href="#只在栈上的数据：拷贝" class="headerlink" title="只在栈上的数据：拷贝"></a>只在栈上的数据：拷贝</h3><p>这里还有一个没有提到的小窍门。这些代码使用了整型并且是有效的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">let x = 5;<br>let y = x;<br><br>println!(&quot;x = &#123;&#125;, y = &#123;&#125;&quot;, x, y);<br></code></pre></td></tr></table></figure>
<p>但这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 clone，不过 x 依然有效且没有被移动到 y 中。</p>
<p>原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效。换句话说，这里没有深浅拷贝的区别，所以这里调用 clone 并不会与通常的浅拷贝有什么不同，我们可以不用管它。</p>
<p>Rust 有一个叫做 Copy trait 的特殊标注，可以用在类似整型这样的存储在栈上的类型上。如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。如果我们对其值离开作用域时需要特殊处理的类型使用 Copy 标注，将会出现一个编译时错误。</p>
<p>如下是一些 Copy 的类型</p>
<ul>
<li>所有整数类型，比如 u32。</li>
<li>布尔类型，bool，它的值是 true 和 false。</li>
<li>所有浮点数类型，比如 f64。</li>
<li>字符类型，char。</li>
<li>元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。</li>
</ul>
<h2 id="所有权与函数"><a href="#所有权与函数" class="headerlink" title="所有权与函数"></a>所有权与函数</h2><p>将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。下面使用注释展示变量何时进入和离开作用域：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">fn main() &#123;<br>  let s = String::from(&quot;hello&quot;);  // s 进入作用域<br><br>  takes_ownership(s);             // s 的值移动到函数里 ...<br>                                  // ... 所以到这里不再有效<br><br>  let x = 5;                      // x 进入作用域<br><br>  makes_copy(x);                  // x 应该移动函数里，<br>                                  // 但 i32 是 Copy 的，所以在后面可继续使用 x<br><br>&#125; // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，<br>  // 所以不会有特殊操作<br><br>fn takes_ownership(some_string: String) &#123; // some_string 进入作用域<br>  println!(&quot;&#123;&#125;&quot;, some_string);<br>&#125; // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放<br><br>fn makes_copy(some_integer: i32) &#123; // some_integer 进入作用域<br>  println!(&quot;&#123;&#125;&quot;, some_integer);<br>&#125; // 这里，some_integer 移出作用域。不会有特殊操作<br></code></pre></td></tr></table></figure>
<p>当尝试在调用 takes_ownership 后使用 s 时，Rust 会抛出一个编译时错误。这些静态检查使我们免于犯错。试试在 main 函数中添加使用 s 和 x 的代码来看看哪里能使用他们，以及所有权规则会在哪里阻止我们这么做。</p>
<h2 id="返回值与作用域"><a href="#返回值与作用域" class="headerlink" title="返回值与作用域"></a>返回值与作用域</h2><p>返回值也可以转移所有权</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">fn main() &#123;<br>  let s1 = gives_ownership();         // gives_ownership 将返回值<br>                                      // 移给 s1<br><br>  let s2 = String::from(&quot;hello&quot;);     // s2 进入作用域<br><br>  let s3 = takes_and_gives_back(s2);  // s2 被移动到<br>                                      // takes_and_gives_back 中,<br>                                      // 它也将返回值移给 s3<br>&#125; // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，<br>  // 所以什么也不会发生。s1 移出作用域并被丢弃<br><br>fn gives_ownership() -&gt; String &#123;           // gives_ownership 将返回值移动给<br>                                           // 调用它的函数<br><br>  let some_string = String::from(&quot;yours&quot;); // some_string 进入作用域<br><br>  some_string                              // 返回 some_string 并移出给调用的函数<br>&#125;<br><br>// takes_and_gives_back 将传入字符串并返回该值<br>fn takes_and_gives_back(a_string: String) -&gt; String &#123; // a_string 进入作用域<br><br>  a_string  // 返回 a_string 并移出给调用的函数<br>&#125;<br></code></pre></td></tr></table></figure>
<p>变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。</p>
<p>在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了，除此之外，我们也可能想返回函数体中产生的一些数据。</p>
<p>我们可以使用元组来返回多个值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">fn main() &#123;<br>    let s1 = String::from(&quot;hello&quot;);<br><br>    let (s2, len) = calculate_length(s1);<br><br>    println!(&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;, s2, len);<br>&#125;<br><br>fn calculate_length(s: String) -&gt; (String, usize) &#123;<br>    let length = s.len(); // len() 返回字符串的长度<br><br>    (s, length)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这未免有些形式主义，而且这种场景应该很常见,幸运的是，Rust 对此提供了一个功能，叫做 引用（references）。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Some</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/05/04/Rust-L1/">http://example.com/2024/05/04/Rust-L1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Somewan world</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Rust-learning%F0%9F%A6%80/">Rust-learning🦀</a></div><div class="post_share"><div class="social-share" data-image="https://img2.imgtp.com/2024/04/30/cXrphmbj.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/05/Rust-L2/" title="Rust-learning -- 所有权（二）"><img class="cover" src="https://img2.imgtp.com/2024/04/30/xfF78sVD.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Rust-learning -- 所有权（二）</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/03/rCore-lab1/" title="rCore lab1"><img class="cover" src="https://img2.imgtp.com/2024/04/30/LhKcUG0w.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">rCore lab1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/05/Rust-L2/" title="Rust-learning -- 所有权（二）"><img class="cover" src="https://img2.imgtp.com/2024/04/30/xfF78sVD.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-05</div><div class="title">Rust-learning -- 所有权（二）</div></div></a></div><div><a href="/2024/05/03/rCore-lab1/" title="rCore lab1"><img class="cover" src="https://img2.imgtp.com/2024/04/30/LhKcUG0w.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-03</div><div class="title">rCore lab1</div></div></a></div><div><a href="/2024/04/30/rCore-ch1/" title="rCore ch1 应用程序执行环境与基本执行环境"><img class="cover" src="https://img2.imgtp.com/2024/04/30/2GRAsC33.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-30</div><div class="title">rCore ch1 应用程序执行环境与基本执行环境</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://img2.imgtp.com/2024/04/30/NSnFYQHs.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Some</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/somewan820"><i class="fab fa-github"></i><span>Somewan's world</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/somewan820" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2176978853@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Rust学习中🦀|xv6二周目</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%88%E4%B8%80%EF%BC%89What-is-ownership%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">所有权（一）What is ownership？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Stack-Heap"><span class="toc-number">1.1.</span> <span class="toc-text">Stack &amp; Heap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99"><span class="toc-number">1.2.</span> <span class="toc-text">所有权规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.3.</span> <span class="toc-text">变量作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">String类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%92%8C%E5%88%86%E9%85%8D"><span class="toc-number">1.5.</span> <span class="toc-text">内存和分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A7%BB%E5%8A%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">变量与数据交互的方式（一）：移动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%85%8B%E9%9A%86"><span class="toc-number">1.5.2.</span> <span class="toc-text">变量与数据交互的方式（二）：克隆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E5%9C%A8%E6%A0%88%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9A%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.5.3.</span> <span class="toc-text">只在栈上的数据：拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">所有权与函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.7.</span> <span class="toc-text">返回值与作用域</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/05/16/xv6-lab1/" title="xv6-lab1 utilties"><img src="https://img2.imgtp.com/2024/04/30/QUGWPqLm.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="xv6-lab1 utilties"/></a><div class="content"><a class="title" href="/2024/05/16/xv6-lab1/" title="xv6-lab1 utilties">xv6-lab1 utilties</a><time datetime="2024-05-16T07:47:20.000Z" title="发表于 2024-05-16 15:47:20">2024-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/16/xv6-lab0/" title="xv6-lab0 环境配置"><img src="https://img2.imgtp.com/2024/04/30/xAPVULsi.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="xv6-lab0 环境配置"/></a><div class="content"><a class="title" href="/2024/05/16/xv6-lab0/" title="xv6-lab0 环境配置">xv6-lab0 环境配置</a><time datetime="2024-05-16T05:30:20.000Z" title="发表于 2024-05-16 13:30:20">2024-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/05/Rust-L2/" title="Rust-learning -- 所有权（二）"><img src="https://img2.imgtp.com/2024/04/30/xfF78sVD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Rust-learning -- 所有权（二）"/></a><div class="content"><a class="title" href="/2024/05/05/Rust-L2/" title="Rust-learning -- 所有权（二）">Rust-learning -- 所有权（二）</a><time datetime="2024-05-05T08:48:44.000Z" title="发表于 2024-05-05 16:48:44">2024-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/04/Rust-L1/" title="Rust-learning -- 所有权（一）"><img src="https://img2.imgtp.com/2024/04/30/cXrphmbj.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Rust-learning -- 所有权（一）"/></a><div class="content"><a class="title" href="/2024/05/04/Rust-L1/" title="Rust-learning -- 所有权（一）">Rust-learning -- 所有权（一）</a><time datetime="2024-05-04T15:48:44.000Z" title="发表于 2024-05-04 23:48:44">2024-05-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/03/rCore-lab1/" title="rCore lab1"><img src="https://img2.imgtp.com/2024/04/30/LhKcUG0w.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="rCore lab1"/></a><div class="content"><a class="title" href="/2024/05/03/rCore-lab1/" title="rCore lab1">rCore lab1</a><time datetime="2024-05-03T11:48:44.000Z" title="发表于 2024-05-03 19:48:44">2024-05-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://img2.imgtp.com/2024/04/30/cXrphmbj.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2024 By Some</div><div class="footer_custom_text"><p> <a style="margin-inline:5px"target="_blank" href="https://hexo.io/"> <img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"> </a> <a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"> <img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"> </a> <a style="margin-inline:5px"target="_blank" href="https://github.com/"> <img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"> </a> <a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"> <img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"> </a> </p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><a class="magnet_link_more"  href="http://example.com/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><!-- hexo injector body_end end --></body></html>